/*
 * generated by Xtext 2.25.0
 */
package org.ppgti.regexdsl.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.ppgti.regexdsl.regexDsl.RegularExpressions
import org.eclipse.xtext.xbase.testing.CompilationTestHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.ppgti.regexdsl.regexDsl.RegexDslPackage
import org.ppgti.regexdsl.validation.RegexDslValidator

@ExtendWith(InjectionExtension)
@InjectWith(RegexDslInjectorProvider)
class RegexDslQuantifierParsingTest {
    @Inject
    ParseHelper<RegularExpressions> parseHelper
    
    @Inject ValidationTestHelper validationTestHelper
    
    @Inject extension CompilationTestHelper
    
    @Test
    def void zeroOrOne() {
        val result = '----- Regular Expressions -----'
            + '\nzero_or_one: ?';
        
        '''
        regex zero_or_one {
            quantifier(min=0, max=1)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void zeroOrMultiple() {
        val result = '----- Regular Expressions -----'
            + '\nzero_or_multiple: *';
        
        '''
        regex zero_or_multiple {
            quantifier(min=0, without_maximum=true)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void OneOrMultiple() {
        val result = '----- Regular Expressions -----'
            + '\none_or_multiple: +';
        
        '''
        regex one_or_multiple {
            quantifier(min=1, without_maximum=true)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void exactlyThree() {
        val result = '----- Regular Expressions -----'
            + '\nexactly_three: {3}';
        
        '''
        regex exactly_three {
            quantifier(size=3)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void twoToFour() {
        val result = '----- Regular Expressions -----'
            + '\ntwo_to_four: {2,4}';
        
        '''
        regex two_to_four {
            quantifier(min=2, max=4)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void threeOrMore() {
        val result = '----- Regular Expressions -----'
            + '\nthree_or_more: {3,}';
        
        '''
        regex three_or_more {
            quantifier(min=3, without_maximum=true)
        }
        '''.assertCompilesTo(result)
    }
    
    @Test
    def void errorAttributesTypeInteger() {
        val entity = parseHelper.parse(
            "regex attributes_type_integer {
                quantifier(size=\"abc\")
            }"
        )
        validationTestHelper.assertError(entity,
            RegexDslPackage.Literals.QUANTIFIER,
            RegexDslValidator.ATTRIBUTES_TYPE_INTEGER,
            "The value of 'size' must be a integer, was given \"abc\""
        )
    }
    
    @Test
    def void errorAttributesTypeBoolean() {
        val entity = parseHelper.parse(
            "regex attributes_type_boolean {
                quantifier(without_maximum=\"abc\")
            }"
        )
        validationTestHelper.assertError(entity,
            RegexDslPackage.Literals.QUANTIFIER,
            RegexDslValidator.ATTRIBUTES_TYPE_BOOLEAN,
            "The value of 'without_maximum' must be a boolean, was given \"abc\""
        )
    }
    
    @Test
    def void errorSizeWithMinAndMax() {
        val entity = parseHelper.parse(
            "regex size_and_min_and_max {
                quantifier(size=1, min=2, max=3)
            }"
        )
        validationTestHelper.assertError(entity,
            RegexDslPackage.Literals.QUANTIFIER,
            RegexDslValidator.SIZE_WITH_MIN_AND_MAX,
            "You can use 'size' or 'min' and 'max', but not these attributes together"
        )
    }
    
    @Test
    def void errorMinGreaterThanMax() {
        val entity = parseHelper.parse(
            "regex min_greater_than_max {
                quantifier(min=3, max=1)
            }"
        )
        validationTestHelper.assertError(entity,
            RegexDslPackage.Literals.QUANTIFIER,
            RegexDslValidator.MIN_GREATER_THAN_MAX,
            "Minimum value must be less than the maximum value"
        )
    }
}
